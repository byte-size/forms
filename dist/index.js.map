{"version":3,"sources":["../node_modules/form-serialize/index.js","../node_modules/tabbable/index.js","../node_modules/xtend/immutable.js","../node_modules/focus-trap/index.js","../src/index.ts","../node_modules/kind-of/index.js","../src/types.ts","../node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../src/struct-error.ts","../src/struct.ts","../src/structs/array.ts","../src/structs/dynamic.ts","../src/structs/enum.ts","../src/structs/function.ts","../src/structs/instance.ts","../src/structs/interface.ts","../src/structs/intersection.ts","../src/structs/lazy.ts","../src/structs/size.ts","../src/structs/literal.ts","../src/structs/object.ts","../src/structs/partial.ts","../src/structs/pick.ts","../src/structs/record.ts","../src/structs/scalar.ts","../src/structs/shorthand.ts","../src/structs/tuple.ts","../src/structs/union.ts","../src/superstruct.ts","Form.Container.vue","index.js"],"names":["module","exports","extend","hasOwnProperty","Object","prototype","target","i","arguments","length","source","key","call","Types","any","value","undefined","kindOf","array","boolean","buffer","date","isNaN","error","float32array","float64array","function","generatorfunction","int16array","int32array","int8array","map","null","number","object","promise","regexp","set","string","symbol","uint16array","uint32array","uint8array","uint8clampedarray","weakmap","weakset","StructError","failures","invariant","first","path","type","branch","rest","message","join","JSON","stringify","assign","stack","Error","__proto__","TypeError","STRUCT","Symbol","isStruct","createStruct","props","struct","Struct","assert","defineProperty","kind","default","defaults","test","check","result","validate","fail","obj","createArray","schema","Array","isArray","Element","v","concat","efs","er","push","createDynamic","Dynamic","createEnum","validator","includes","s","createFunction","r","createInstance","name","createInterface","Props","keys","k","Prop","pfs","createIntersection","Structs","sch","fs","createLazy","Lazy","createSize","every","n","min","max","createLiteral","createObject","d","Set","p","b","pr","createPartial","union","createPick","createRecord","Key","Value","defs","kfs","kr","vfs","vr","createScalar","createShorthand","tuple","optional","endsWith","slice","scalars","split","intersection","scalar","createTuple","Elements","S","Math","createUnion","superstruct","settings","dynamic","enum","instance","interface","lazy","literal","partial","pick","record","size","BuiltinTypes","types","install","Vue","options","component","FormContainer"],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["// get successful control from form and assemble into object\n// http://www.w3.org/TR/html401/interact/forms.html#h-17.13.2\n\n// types which indicate a submit action and are not successful controls\n// these will be ignored\nvar k_r_submitter = /^(?:submit|button|image|reset|file)$/i;\n\n// node names which could be successful controls\nvar k_r_success_contrls = /^(?:input|select|textarea|keygen)/i;\n\n// Matches bracket notation.\nvar brackets = /(\\[[^\\[\\]]*\\])/g;\n\n// serializes form fields\n// @param form MUST be an HTMLForm element\n// @param options is an optional argument to configure the serialization. Default output\n// with no options specified is a url encoded string\n//    - hash: [true | false] Configure the output type. If true, the output will\n//    be a js object.\n//    - serializer: [function] Optional serializer function to override the default one.\n//    The function takes 3 arguments (result, key, value) and should return new result\n//    hash and url encoded str serializers are provided with this module\n//    - disabled: [true | false]. If true serialize disabled fields.\n//    - empty: [true | false]. If true serialize empty fields\nfunction serialize(form, options) {\n    if (typeof options != 'object') {\n        options = { hash: !!options };\n    }\n    else if (options.hash === undefined) {\n        options.hash = true;\n    }\n\n    var result = (options.hash) ? {} : '';\n    var serializer = options.serializer || ((options.hash) ? hash_serializer : str_serialize);\n\n    var elements = form && form.elements ? form.elements : [];\n\n    //Object store each radio and set if it's empty or not\n    var radio_store = Object.create(null);\n\n    for (var i=0 ; i<elements.length ; ++i) {\n        var element = elements[i];\n\n        // ingore disabled fields\n        if ((!options.disabled && element.disabled) || !element.name) {\n            continue;\n        }\n        // ignore anyhting that is not considered a success field\n        if (!k_r_success_contrls.test(element.nodeName) ||\n            k_r_submitter.test(element.type)) {\n            continue;\n        }\n\n        var key = element.name;\n        var val = element.value;\n\n        // we can't just use element.value for checkboxes cause some browsers lie to us\n        // they say \"on\" for value when the box isn't checked\n        if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {\n            val = undefined;\n        }\n\n        // If we want empty elements\n        if (options.empty) {\n            // for checkbox\n            if (element.type === 'checkbox' && !element.checked) {\n                val = '';\n            }\n\n            // for radio\n            if (element.type === 'radio') {\n                if (!radio_store[element.name] && !element.checked) {\n                    radio_store[element.name] = false;\n                }\n                else if (element.checked) {\n                    radio_store[element.name] = true;\n                }\n            }\n\n            // if options empty is true, continue only if its radio\n            if (val == undefined && element.type == 'radio') {\n                continue;\n            }\n        }\n        else {\n            // value-less fields are ignored unless options.empty is true\n            if (!val) {\n                continue;\n            }\n        }\n\n        // multi select boxes\n        if (element.type === 'select-multiple') {\n            val = [];\n\n            var selectOptions = element.options;\n            var isSelectedOptions = false;\n            for (var j=0 ; j<selectOptions.length ; ++j) {\n                var option = selectOptions[j];\n                var allowedEmpty = options.empty && !option.value;\n                var hasValue = (option.value || allowedEmpty);\n                if (option.selected && hasValue) {\n                    isSelectedOptions = true;\n\n                    // If using a hash serializer be sure to add the\n                    // correct notation for an array in the multi-select\n                    // context. Here the name attribute on the select element\n                    // might be missing the trailing bracket pair. Both names\n                    // \"foo\" and \"foo[]\" should be arrays.\n                    if (options.hash && key.slice(key.length - 2) !== '[]') {\n                        result = serializer(result, key + '[]', option.value);\n                    }\n                    else {\n                        result = serializer(result, key, option.value);\n                    }\n                }\n            }\n\n            // Serialize if no selected options and options.empty is true\n            if (!isSelectedOptions && options.empty) {\n                result = serializer(result, key, '');\n            }\n\n            continue;\n        }\n\n        result = serializer(result, key, val);\n    }\n\n    // Check for all empty radio buttons and serialize them with key=\"\"\n    if (options.empty) {\n        for (var key in radio_store) {\n            if (!radio_store[key]) {\n                result = serializer(result, key, '');\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction parse_keys(string) {\n    var keys = [];\n    var prefix = /^([^\\[\\]]*)/;\n    var children = new RegExp(brackets);\n    var match = prefix.exec(string);\n\n    if (match[1]) {\n        keys.push(match[1]);\n    }\n\n    while ((match = children.exec(string)) !== null) {\n        keys.push(match[1]);\n    }\n\n    return keys;\n}\n\nfunction hash_assign(result, keys, value) {\n    if (keys.length === 0) {\n        result = value;\n        return result;\n    }\n\n    var key = keys.shift();\n    var between = key.match(/^\\[(.+?)\\]$/);\n\n    if (key === '[]') {\n        result = result || [];\n\n        if (Array.isArray(result)) {\n            result.push(hash_assign(null, keys, value));\n        }\n        else {\n            // This might be the result of bad name attributes like \"[][foo]\",\n            // in this case the original `result` object will already be\n            // assigned to an object literal. Rather than coerce the object to\n            // an array, or cause an exception the attribute \"_values\" is\n            // assigned as an array.\n            result._values = result._values || [];\n            result._values.push(hash_assign(null, keys, value));\n        }\n\n        return result;\n    }\n\n    // Key is an attribute name and can be assigned directly.\n    if (!between) {\n        result[key] = hash_assign(result[key], keys, value);\n    }\n    else {\n        var string = between[1];\n        // +var converts the variable into a number\n        // better than parseInt because it doesn't truncate away trailing\n        // letters and actually fails if whole thing is not a number\n        var index = +string;\n\n        // If the characters between the brackets is not a number it is an\n        // attribute name and can be assigned directly.\n        if (isNaN(index)) {\n            result = result || {};\n            result[string] = hash_assign(result[string], keys, value);\n        }\n        else {\n            result = result || [];\n            result[index] = hash_assign(result[index], keys, value);\n        }\n    }\n\n    return result;\n}\n\n// Object/hash encoding serializer.\nfunction hash_serializer(result, key, value) {\n    var matches = key.match(brackets);\n\n    // Has brackets? Use the recursive assignment function to walk the keys,\n    // construct any missing objects in the result tree and make the assignment\n    // at the end of the chain.\n    if (matches) {\n        var keys = parse_keys(key);\n        hash_assign(result, keys, value);\n    }\n    else {\n        // Non bracket notation can make assignments directly.\n        var existing = result[key];\n\n        // If the value has been assigned already (for instance when a radio and\n        // a checkbox have the same name attribute) convert the previous value\n        // into an array before pushing into it.\n        //\n        // NOTE: If this requirement were removed all hash creation and\n        // assignment could go through `hash_assign`.\n        if (existing) {\n            if (!Array.isArray(existing)) {\n                result[key] = [ existing ];\n            }\n\n            result[key].push(value);\n        }\n        else {\n            result[key] = value;\n        }\n    }\n\n    return result;\n}\n\n// urlform encoding serializer\nfunction str_serialize(result, key, value) {\n    // encode newlines as \\r\\n cause the html spec says so\n    value = value.replace(/(\\r)?\\n/g, '\\r\\n');\n    value = encodeURIComponent(value);\n\n    // spaces should be '+' rather than '%20'.\n    value = value.replace(/%20/g, '+');\n    return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;\n}\n\nmodule.exports = serialize;\n","var candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n];\nvar candidateSelector = candidateSelectors.join(',');\n\nvar matches = typeof Element === 'undefined'\n  ? function () {}\n  : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nfunction tabbable(el, options) {\n  options = options || {};\n\n  var regularTabbables = [];\n  var orderedTabbables = [];\n\n  var candidates = el.querySelectorAll(candidateSelector);\n\n  if (options.includeContainer) {\n    if (matches.call(el, candidateSelector)) {\n      candidates = Array.prototype.slice.apply(candidates);\n      candidates.unshift(el);\n    }\n  }\n\n  var i, candidate, candidateTabindex;\n  for (i = 0; i < candidates.length; i++) {\n    candidate = candidates[i];\n\n    if (!isNodeMatchingSelectorTabbable(candidate)) continue;\n\n    candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  }\n\n  var tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map(function(a) { return a.node })\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n}\n\ntabbable.isTabbable = isTabbable;\ntabbable.isFocusable = isFocusable;\n\nfunction isNodeMatchingSelectorTabbable(node) {\n  if (\n    !isNodeMatchingSelectorFocusable(node)\n    || isNonTabbableRadio(node)\n    || getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n}\n\nfunction isTabbable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, candidateSelector) === false) return false;\n  return isNodeMatchingSelectorTabbable(node);\n}\n\nfunction isNodeMatchingSelectorFocusable(node) {\n  if (\n    node.disabled\n    || isHiddenInput(node)\n    || isHidden(node)\n  ) {\n    return false;\n  }\n  return true;\n}\n\nvar focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');\nfunction isFocusable(node) {\n  if (!node) throw new Error('No node provided');\n  if (matches.call(node, focusableCandidateSelector) === false) return false;\n  return isNodeMatchingSelectorFocusable(node);\n}\n\nfunction getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n  if (!isNaN(tabindexAttr)) return tabindexAttr;\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) return 0;\n  return node.tabIndex;\n}\n\nfunction sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n}\n\nfunction isContentEditable(node) {\n  return node.contentEditable === 'true';\n}\n\nfunction isInput(node) {\n  return node.tagName === 'INPUT';\n}\n\nfunction isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n}\n\nfunction isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n}\n\nfunction isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n}\n\nfunction getCheckedRadio(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked) {\n      return nodes[i];\n    }\n  }\n}\n\nfunction isTabbableRadio(node) {\n  if (!node.name) return true;\n  // This won't account for the edge case where you have radio groups with the same\n  // in separate forms on the same page.\n  var radioSet = node.ownerDocument.querySelectorAll('input[type=\"radio\"][name=\"' + node.name + '\"]');\n  var checked = getCheckedRadio(radioSet);\n  return !checked || checked === node;\n}\n\nfunction isHidden(node) {\n  // offsetParent being null will allow detecting cases where an element is invisible or inside an invisible element,\n  // as long as the element does not use position: fixed. For them, their visibility has to be checked directly as well.\n  return node.offsetParent === null || getComputedStyle(node).visibility === 'hidden';\n}\n\nmodule.exports = tabbable;\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","var tabbable = require('tabbable');\nvar xtend = require('xtend');\n\nvar activeFocusDelay;\n\nvar activeFocusTraps = (function() {\n  var trapQueue = [];\n  return {\n    activateTrap: function(trap) {\n      if (trapQueue.length > 0) {\n        var activeTrap = trapQueue[trapQueue.length - 1];\n        if (activeTrap !== trap) {\n          activeTrap.pause();\n        }\n      }\n\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex === -1) {\n        trapQueue.push(trap);\n      } else {\n        // move this existing trap to the front of the queue\n        trapQueue.splice(trapIndex, 1);\n        trapQueue.push(trap);\n      }\n    },\n\n    deactivateTrap: function(trap) {\n      var trapIndex = trapQueue.indexOf(trap);\n      if (trapIndex !== -1) {\n        trapQueue.splice(trapIndex, 1);\n      }\n\n      if (trapQueue.length > 0) {\n        trapQueue[trapQueue.length - 1].unpause();\n      }\n    }\n  };\n})();\n\nfunction focusTrap(element, userOptions) {\n  var doc = document;\n  var container =\n    typeof element === 'string' ? doc.querySelector(element) : element;\n\n  var config = xtend(\n    {\n      returnFocusOnDeactivate: true,\n      escapeDeactivates: true\n    },\n    userOptions\n  );\n\n  var state = {\n    firstTabbableNode: null,\n    lastTabbableNode: null,\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false\n  };\n\n  var trap = {\n    activate: activate,\n    deactivate: deactivate,\n    pause: pause,\n    unpause: unpause\n  };\n\n  return trap;\n\n  function activate(activateOptions) {\n    if (state.active) return;\n\n    updateTabbableNodes();\n\n    state.active = true;\n    state.paused = false;\n    state.nodeFocusedBeforeActivation = doc.activeElement;\n\n    var onActivate =\n      activateOptions && activateOptions.onActivate\n        ? activateOptions.onActivate\n        : config.onActivate;\n    if (onActivate) {\n      onActivate();\n    }\n\n    addListeners();\n    return trap;\n  }\n\n  function deactivate(deactivateOptions) {\n    if (!state.active) return;\n\n    clearTimeout(activeFocusDelay);\n\n    removeListeners();\n    state.active = false;\n    state.paused = false;\n\n    activeFocusTraps.deactivateTrap(trap);\n\n    var onDeactivate =\n      deactivateOptions && deactivateOptions.onDeactivate !== undefined\n        ? deactivateOptions.onDeactivate\n        : config.onDeactivate;\n    if (onDeactivate) {\n      onDeactivate();\n    }\n\n    var returnFocus =\n      deactivateOptions && deactivateOptions.returnFocus !== undefined\n        ? deactivateOptions.returnFocus\n        : config.returnFocusOnDeactivate;\n    if (returnFocus) {\n      delay(function() {\n        tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n      });\n    }\n\n    return trap;\n  }\n\n  function pause() {\n    if (state.paused || !state.active) return;\n    state.paused = true;\n    removeListeners();\n  }\n\n  function unpause() {\n    if (!state.paused || !state.active) return;\n    state.paused = false;\n    updateTabbableNodes();\n    addListeners();\n  }\n\n  function addListeners() {\n    if (!state.active) return;\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    activeFocusDelay = delay(function() {\n      tryFocus(getInitialFocusNode());\n    });\n\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n\n    return trap;\n  }\n\n  function removeListeners() {\n    if (!state.active) return;\n\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n\n    return trap;\n  }\n\n  function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    var node = optionValue;\n    if (!optionValue) {\n      return null;\n    }\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue);\n      if (!node) {\n        throw new Error('`' + optionName + '` refers to no known node');\n      }\n    }\n    if (typeof optionValue === 'function') {\n      node = optionValue();\n      if (!node) {\n        throw new Error('`' + optionName + '` did not return a node');\n      }\n    }\n    return node;\n  }\n\n  function getInitialFocusNode() {\n    var node;\n    if (getNodeForOption('initialFocus') !== null) {\n      node = getNodeForOption('initialFocus');\n    } else if (container.contains(doc.activeElement)) {\n      node = doc.activeElement;\n    } else {\n      node = state.firstTabbableNode || getNodeForOption('fallbackFocus');\n    }\n\n    if (!node) {\n      throw new Error(\n        'Your focus-trap needs to have at least one focusable element'\n      );\n    }\n\n    return node;\n  }\n\n  function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus');\n    return node ? node : previousActiveElement;\n  }\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  function checkPointerDown(e) {\n    if (container.contains(e.target)) return;\n    if (config.clickOutsideDeactivates) {\n      deactivate({\n        returnFocus: !tabbable.isFocusable(e.target)\n      });\n      return;\n    }\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (config.allowOutsideClick && config.allowOutsideClick(e)) {\n      return;\n    }\n    e.preventDefault();\n  }\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  function checkFocusIn(e) {\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (container.contains(e.target) || e.target instanceof Document) {\n      return;\n    }\n    e.stopImmediatePropagation();\n    tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n  }\n\n  function checkKey(e) {\n    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {\n      e.preventDefault();\n      deactivate();\n      return;\n    }\n    if (isTabEvent(e)) {\n      checkTab(e);\n      return;\n    }\n  }\n\n  // Hijack Tab events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  function checkTab(e) {\n    updateTabbableNodes();\n    if (e.shiftKey && e.target === state.firstTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.lastTabbableNode);\n      return;\n    }\n    if (!e.shiftKey && e.target === state.lastTabbableNode) {\n      e.preventDefault();\n      tryFocus(state.firstTabbableNode);\n      return;\n    }\n  }\n\n  function checkClick(e) {\n    if (config.clickOutsideDeactivates) return;\n    if (container.contains(e.target)) return;\n    if (config.allowOutsideClick && config.allowOutsideClick(e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  }\n\n  function updateTabbableNodes() {\n    var tabbableNodes = tabbable(container);\n    state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();\n    state.lastTabbableNode =\n      tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();\n  }\n\n  function tryFocus(node) {\n    if (node === doc.activeElement) return;\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus();\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  }\n}\n\nfunction isSelectableInput(node) {\n  return (\n    node.tagName &&\n    node.tagName.toLowerCase() === 'input' &&\n    typeof node.select === 'function'\n  );\n}\n\nfunction isEscapeEvent(e) {\n  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;\n}\n\nfunction isTabEvent(e) {\n  return e.key === 'Tab' || e.keyCode === 9;\n}\n\nfunction delay(fn) {\n  return setTimeout(fn, 0);\n}\n\nmodule.exports = focusTrap;\n","import { superstruct } from './superstruct'\n\n/**\n * The singleton instance of Superstruct that is exported by default, configured\n * with types for all of the JavaScript built-in data types.\n *\n * You can use it if you don't need any custom types. However, if you do want to\n * define custom types, use the [[superstruct]] factory to configure your own\n * [[Superstruct]] instance.\n */\n\nconst struct = superstruct()\n\nexport { struct, superstruct }\nexport { Superstruct } from './superstruct'\nexport { StructError, Failure, Path, Branch } from './struct-error'\nexport { Types, Validator } from './types'\nexport { isStruct, Struct } from './struct'\n","var toString = Object.prototype.toString;\n\nmodule.exports = function kindOf(val) {\n  if (val === void 0) return 'undefined';\n  if (val === null) return 'null';\n\n  var type = typeof val;\n  if (type === 'boolean') return 'boolean';\n  if (type === 'string') return 'string';\n  if (type === 'number') return 'number';\n  if (type === 'symbol') return 'symbol';\n  if (type === 'function') {\n    return isGeneratorFn(val) ? 'generatorfunction' : 'function';\n  }\n\n  if (isArray(val)) return 'array';\n  if (isBuffer(val)) return 'buffer';\n  if (isArguments(val)) return 'arguments';\n  if (isDate(val)) return 'date';\n  if (isError(val)) return 'error';\n  if (isRegexp(val)) return 'regexp';\n\n  switch (ctorName(val)) {\n    case 'Symbol': return 'symbol';\n    case 'Promise': return 'promise';\n\n    // Set, Map, WeakSet, WeakMap\n    case 'WeakMap': return 'weakmap';\n    case 'WeakSet': return 'weakset';\n    case 'Map': return 'map';\n    case 'Set': return 'set';\n\n    // 8-bit typed arrays\n    case 'Int8Array': return 'int8array';\n    case 'Uint8Array': return 'uint8array';\n    case 'Uint8ClampedArray': return 'uint8clampedarray';\n\n    // 16-bit typed arrays\n    case 'Int16Array': return 'int16array';\n    case 'Uint16Array': return 'uint16array';\n\n    // 32-bit typed arrays\n    case 'Int32Array': return 'int32array';\n    case 'Uint32Array': return 'uint32array';\n    case 'Float32Array': return 'float32array';\n    case 'Float64Array': return 'float64array';\n  }\n\n  if (isGeneratorObj(val)) {\n    return 'generator';\n  }\n\n  // Non-plain objects\n  type = toString.call(val);\n  switch (type) {\n    case '[object Object]': return 'object';\n    // iterators\n    case '[object Map Iterator]': return 'mapiterator';\n    case '[object Set Iterator]': return 'setiterator';\n    case '[object String Iterator]': return 'stringiterator';\n    case '[object Array Iterator]': return 'arrayiterator';\n  }\n\n  // other\n  return type.slice(8, -1).toLowerCase().replace(/\\s/g, '');\n};\n\nfunction ctorName(val) {\n  return val.constructor ? val.constructor.name : null;\n}\n\nfunction isArray(val) {\n  if (Array.isArray) return Array.isArray(val);\n  return val instanceof Array;\n}\n\nfunction isError(val) {\n  return val instanceof Error || (typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number');\n}\n\nfunction isDate(val) {\n  if (val instanceof Date) return true;\n  return typeof val.toDateString === 'function'\n    && typeof val.getDate === 'function'\n    && typeof val.setDate === 'function';\n}\n\nfunction isRegexp(val) {\n  if (val instanceof RegExp) return true;\n  return typeof val.flags === 'string'\n    && typeof val.ignoreCase === 'boolean'\n    && typeof val.multiline === 'boolean'\n    && typeof val.global === 'boolean';\n}\n\nfunction isGeneratorFn(name, val) {\n  return ctorName(name) === 'GeneratorFunction';\n}\n\nfunction isGeneratorObj(val) {\n  return typeof val.throw === 'function'\n    && typeof val.return === 'function'\n    && typeof val.next === 'function';\n}\n\nfunction isArguments(val) {\n  try {\n    if (typeof val.length === 'number' && typeof val.callee === 'function') {\n      return true;\n    }\n  } catch (err) {\n    if (err.message.indexOf('callee') !== -1) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * If you need to support Safari 5-7 (8-10 yr-old browser),\n * take a look at https://github.com/feross/is-buffer\n */\n\nfunction isBuffer(val) {\n  if (val.constructor && typeof val.constructor.isBuffer === 'function') {\n    return val.constructor.isBuffer(val);\n  }\n  return false;\n}\n","import kindOf from 'kind-of'\nimport { Branch, Path, Failure } from './struct-error'\n\n/**\n * Superstruct ships by default with an unopinionated set of scalar types that\n * express all of the data types that are built-in to JavaScript.\n */\n\nexport const Types = {\n  /**\n   * Matches any value other than `undefined`.\n   *\n   * ```js\n   * 'anything'\n   * true\n   * ```\n   */\n\n  any: (value: any) => value !== undefined,\n\n  /**\n   * Matches an `arguments` object.\n   *\n   * ```js\n   * arguments\n   * ```\n   */\n\n  arguments: (value: any) => kindOf(value) === 'arguments',\n\n  /**\n   * Matches an `Array`.\n   *\n   * ```js\n   * [1, 2, 3]\n   * ```\n   */\n\n  array: (value: any) => kindOf(value) === 'array',\n\n  /**\n   * Matches a boolean.\n   *\n   * ```js\n   * true\n   * false\n   * ```\n   */\n\n  boolean: (value: any) => kindOf(value) === 'boolean',\n\n  /**\n   * Matches a Node.js `Buffer`.\n   *\n   * ```js\n   * Buffer.from('string')\n   * ```\n   */\n\n  buffer: (value: any) => kindOf(value) === 'buffer',\n\n  /**\n   * Matches a **valid** `Date` object.\n   *\n   * ```js\n   * new Date()\n   * ```\n   *\n   * Note: Invalid `Date` objects that equal `NaN` are not matched.\n   */\n\n  date: (value: any) => kindOf(value) === 'date' && !isNaN(value),\n\n  /**\n   * Matches an error object.\n   *\n   * ```js\n   * new Error()\n   * ```\n   */\n\n  error: (value: any) => kindOf(value) === 'error',\n\n  /**\n   * Matches a `Float32Array` object.\n   */\n\n  float32array: (value: any) => kindOf(value) === 'float32array',\n\n  /**\n   * Matches a `Float64Array` object.\n   */\n\n  float64array: (value: any) => kindOf(value) === 'float64array',\n\n  /**\n   * Matches a function.\n   *\n   * ```js\n   * () => {}\n   * function () {}\n   * ```\n   */\n\n  function: (value: any) => kindOf(value) === 'function',\n\n  /**\n   * Matches a generator function.\n   *\n   * ```js\n   * function* () {}\n   * ```\n   */\n\n  generatorfunction: (value: any) => kindOf(value) === 'generatorfunction',\n\n  /**\n   * Matches a `Int16Array` object.\n   */\n\n  int16array: (value: any) => kindOf(value) === 'int16array',\n\n  /**\n   * Matches a `Int32Array` object.\n   */\n\n  int32array: (value: any) => kindOf(value) === 'int32array',\n\n  /**\n   * Matches a `Int8Array` object.\n   */\n\n  int8array: (value: any) => kindOf(value) === 'int8array',\n\n  /**\n   * Matches a `Map` object.\n   *\n   * ```js\n   * new Map()\n   * ```\n   */\n\n  map: (value: any) => kindOf(value) === 'map',\n\n  /**\n   * Matches the `null` literal value.\n   *\n   * ```js\n   * null\n   * ```\n   */\n\n  null: (value: any) => kindOf(value) === 'null',\n\n  /**\n   * Matches a number.\n   *\n   * ```js\n   * 42\n   * ```\n   */\n\n  number: (value: any) => kindOf(value) === 'number',\n\n  /**\n   * Matches a plain object.\n   *\n   * ```js\n   * { key: 'value' }\n   * { something: true }\n   * ```\n   */\n\n  object: (value: any) => kindOf(value) === 'object',\n\n  /**\n   * Matches a `Promise` object.\n   *\n   * ```js\n   * Promise.resolve()\n   * ```\n   */\n\n  promise: (value: any) => kindOf(value) === 'promise',\n\n  /**\n   * Matches a regular expression object.\n   *\n   * ```js\n   * /a-z/g\n   * ```\n   */\n\n  regexp: (value: any) => kindOf(value) === 'regexp',\n\n  /**\n   * Matches a `Set` object.\n   *\n   * ```js\n   * new Set()\n   * ```\n   */\n\n  set: (value: any) => kindOf(value) === 'set',\n\n  /**\n   * Matches a string.\n   *\n   * ```js\n   * 'text'\n   * ```\n   */\n\n  string: (value: any) => kindOf(value) === 'string',\n\n  /**\n   * Matches a `Symbol`.\n   *\n   * ```js\n   * Symbol()\n   * ```\n   */\n\n  symbol: (value: any) => kindOf(value) === 'symbol',\n\n  /**\n   * Matches a `Uint16Array` object.\n   */\n\n  uint16array: (value: any) => kindOf(value) === 'uint16array',\n\n  /**\n   * Matches a `Uint32Array` object.\n   */\n\n  uint32array: (value: any) => kindOf(value) === 'uint32array',\n\n  /**\n   * Matches a `Uint8Array` object.\n   */\n\n  uint8array: (value: any) => kindOf(value) === 'uint8array',\n\n  /**\n   * Matches a `Uint8ClampedArray` object.\n   */\n\n  uint8clampedarray: (value: any) => kindOf(value) === 'uint8clampedarray',\n\n  /**\n   * Matches the `undefined` literal value.\n   *\n   * ```js\n   * undefined\n   * ```\n   */\n\n  undefined: (value: any) => kindOf(value) === 'undefined',\n\n  /**\n   * Matches a `WeakMap` object.\n   *\n   * ```js\n   * new WeakMap()\n   * ```\n   */\n\n  weakmap: (value: any) => kindOf(value) === 'weakmap',\n\n  /**\n   * Matches a `WeakSet` object.\n   *\n   * ```js\n   * new WeakSet()\n   * ```\n   */\n\n  weakset: (value: any) => kindOf(value) === 'weakset',\n}\n\n/**\n * `Validator` functions allow developers to define their own scalar types for\n * Superstruct to validate against, and return an indication of what is invalid.\n *\n * ```js\n * import { superstruct } from 'superstruct'\n * import isEmail from 'is-email'\n *\n * const struct = superstruct({\n *   types: {\n *     email: value => isEmail(value) && value.length < 256,\n *   }\n * })\n * ```\n */\n\nexport type Validator = (\n  value: any,\n  branch: Branch,\n  path: Path\n) => Partial<Failure>[] | Partial<Failure> | boolean\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n\nexport default invariant;\n","import invariant from 'tiny-invariant'\n\n/**\n * `StructError` objects are thrown (or returned) by Superstruct when its\n * validation fails. The error represents the first error encountered during\n * validation. But they also have an `error.failures` property that holds\n * information for all of the failures encountered.\n */\n\nexport class StructError extends TypeError {\n  branch: Branch\n  failures: Failure[]\n  path: Path\n  type: string | undefined\n  value: any\n  [key: string]: any\n\n  constructor(failures: Failure[]) {\n    invariant(\n      failures.length > 0,\n      `StructError requires being passed a failure, but received: ${failures}`\n    )\n\n    const [first] = failures\n    const { path, value, type, branch, ...rest } = first\n    const message = `Expected a value of type \\`${type}\\`${\n      path.length ? ` for \\`${path.join('.')}\\`` : ''\n    } but received \\`${JSON.stringify(value)}\\`.`\n\n    super(message)\n    this.type = type\n    this.value = value\n    Object.assign(this, rest)\n    this.path = path\n    this.branch = branch\n    this.failures = failures\n    this.stack = new Error().stack\n    ;(this as any).__proto__ = StructError.prototype\n  }\n}\n\n/**\n * `Path` arrays specify a nested value's location in a root object or array.\n *\n * ```js\n * ['user', 'address', 'city']\n * ['nodes', 1, 'nodes', 0, 'text']\n * ```\n */\n\nexport type Path = Array<number | string>\n\n/**\n * `Branch` arrays contain each value following a path down from the root.\n *\n * ```js\n * [root, ..., parent, value]\n * ```\n */\n\nexport type Branch = Array<any>\n\n/**\n * `Failure` objects represent a specific failure in validation. They are plain\n * objects that can be turned into real `StructError` when needed.\n *\n * ```js\n * {\n *   type: 'number',\n *   value: 'invalid',\n *   path: [1],\n *   branch: [\n *     [1, 'invalid', 2],\n *     'invalid',\n *   ]\n * }\n */\n\nexport type Failure = {\n  /**\n   * The branch of values following a path down from the root.\n   */\n\n  branch: Branch\n\n  /**\n   * The path of indices to retrieve the failing value from the root.\n   */\n\n  path: Path\n\n  /**\n   * The failing value.\n   */\n\n  value: any\n\n  /**\n   * The expected type description of the failing value, or `undefined` if it\n   * didn't have an expected type.\n   */\n\n  type: string | undefined\n\n  /**\n   * Failures can also be augmented with any of your on custom properties.\n   */\n\n  [key: string]: any\n}\n","import { Failure, Branch, Path } from './struct-error'\nimport { Superstruct } from './superstruct'\n\n/**\n * A symbol to set on `Struct` objects to test them against later.\n */\n\nexport const STRUCT = Symbol('STRUCT')\n\n/**\n * Check if a value is a `Struct` object.\n */\n\nexport const isStruct = (value: any): value is Struct => {\n  return typeof value === 'function' && value[STRUCT]\n}\n\n/**\n * This abstract `Struct` factory creates a generic struct that validates values\n * against a `Validator` function.\n */\n\nexport const createStruct = (props: {\n  kind: string\n  type: string\n  defaults: () => any\n  struct: Superstruct\n}): Struct => {\n  const { struct } = props\n  const { Error } = struct\n  const Struct = (value: any): any => Struct.assert(value)\n\n  // Set a hidden symbol property so that we can check it later to see if an\n  // object is a struct object.\n  Object.defineProperty(Struct, STRUCT, { value: true })\n\n  Struct.kind = props.kind\n  Struct.type = props.type\n\n  Struct.default = () => {\n    return typeof props.defaults === 'function'\n      ? props.defaults()\n      : props.defaults\n  }\n\n  Struct.test = (value: any): boolean => {\n    const [failures] = Struct.check(value, [value], [])\n    return !failures\n  }\n\n  Struct.assert = (value: any): any => {\n    const [failures, result] = Struct.check(value, [value], [])\n\n    if (failures) {\n      throw new Error(failures)\n    } else {\n      return result\n    }\n  }\n\n  Struct.validate = (value: any): [Error?, any?] => {\n    const [failures, result] = Struct.check(value, [value], [])\n\n    if (failures) {\n      return [new Error(failures)]\n    } else {\n      return [undefined, result]\n    }\n  }\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const failures = [Struct.fail({ value, branch, path })]\n    return [failures]\n  }\n\n  Struct.fail = (obj: {\n    value: any\n    branch: Branch\n    path: Path\n    type?: string\n  }): Failure => {\n    return { ...obj, type: 'type' in obj ? obj.type : Struct.type }\n  }\n\n  return Struct\n}\n\n/**\n * `Struct` validators encapsulate the validation logic for a specific type of\n * data (either custom or built-in). They have a set of methods that allow you\n * to validate input in various ways, while producing detailed errors.\n *\n * They are created by the [[Superstruct]] factory functions. You can call them\n * directly for the simple case, or use one of their validation methods.\n *\n * ```js\n * const Struct = struct({\n *   id: 'number',\n *   name: 'string',\n * })\n *\n * const result = Struct(data) // Throws if invalid!\n *\n * const [error, result] = Struct.validate(data)\n *\n * if (Struct.test(data)) {\n *    // ...\n * }\n * ```\n */\n\nexport interface Struct {\n  /**\n   * All structs are functions that are shorthand for calling [[Struct.assert]].\n   */\n\n  (value: any): any\n\n  /**\n   * The struct's name.\n   *\n   * ```js\n   * 'object'\n   * 'union'\n   * 'email'\n   * ```\n   */\n\n  kind: string\n\n  /**\n   * A string representing the type of the struct. These strings are purely for\n   * user-facing error messages, and aren't canonical. They are similar to the\n   * syntax that TypeScript uses.\n   *\n   * ```js\n   * '{id,name,email}'\n   * 'string | number'\n   * 'email'\n   * ```\n   */\n\n  type: string\n\n  /**\n   * Get the default value for a struct.\n   *\n   * ```js\n   * const defaults = Struct.default()\n   * ```\n   */\n\n  default(): any\n\n  /**\n   * Run the low-level validation function a struct, returning a tuple that\n   * contains either a list of [[Failure]] objects, or a resulting value.\n   *\n   * This method is fairly low-level and not for normal use.\n   *\n   * ```js\n   * const [failures, result] = Struct.check(value, branch, path)\n   * ```\n   */\n\n  check(value: any, branch: Branch, path: Path): [Failure[]?, any?]\n\n  /**\n   * Validate a `value`, returning the resulting value, and throwing an error if\n   * validation fails.\n   *\n   * ```js\n   * try {\n   *   const result = Struct.assert(value)\n   *   // ...\n   * } catch (e) {\n   *   // ...\n   * }\n   * ```\n   */\n\n  assert(value: any): any\n\n  /**\n   * Validate a `value`, returning a boolean indicating whether it's valid.\n   *\n   * Note: Using this method does not give you access to the defaults that may\n   * be associated with a struct, so it doesn't guarantee that the value you\n   * have passes, just that the value with defaults passes.\n   *\n   * ```js\n   * if (Struct.test(value)) {\n   *   // ...\n   * }\n   * ```\n   */\n\n  test(value: any): boolean\n\n  /**\n   * Validate a `value` returning a tuple containing an error if the validation\n   * fails, or the resulting value if it succeeds.\n   *\n   * ```js\n   * const [error, result] = Struct.validate(value)\n   * ```\n   */\n\n  validate(value: any): [Error?, any?]\n\n  /**\n   * Create a low-level [[Failure]] object for the struct.\n   *\n   * ```js\n   * const failure = Struct.fail({ value, branch, path })\n   * ```\n   */\n\n  fail(obj: { value: any; branch: Branch; path: Path; type?: string }): Failure\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createArray = (\n  schema: [any],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length === 1,\n    `Array structs must be defined as an array with one element, but you passed: ${schema}`\n  )\n\n  const Element = struct(schema[0], undefined)\n  const Struct = createStruct({\n    kind: 'array',\n    type: `${Element.type}[]`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = []\n    const failures: Failure[] = []\n\n    for (let i = 0; i < value.length; i++) {\n      const v = value[i]\n      const [efs, er] = Element.check(v, branch.concat(v), path.concat(i))\n\n      if (efs) {\n        failures.push(...efs)\n        continue\n      }\n\n      result[i] = er\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createDynamic = (\n  schema: (value: any, branch: Branch, path: Path) => Struct,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Dynamic structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const Dynamic = createStruct({\n    kind: 'dynamic',\n    type: `dynamic<>`,\n    defaults,\n    struct,\n  })\n\n  Dynamic.check = (\n    value: any = Dynamic.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const Struct = schema(value, branch, path)\n    return Struct.check(value, branch, path)\n  }\n\n  return Dynamic\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createEnum = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema),\n    `Enum structs must be defined as an array, but you passed: ${schema}`\n  )\n\n  const validator = (value: any) => schema.includes(value)\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'enum'\n  Struct.type = schema\n    .map(s => (typeof s === 'string' ? `\"${s}\"` : `${s}`))\n    .join(' | ')\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct, Validator } from '..'\nimport { createStruct } from '../struct'\n\nexport const createFunction = (\n  schema: Validator,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  const Struct = createStruct({\n    kind: 'function',\n    type: `function<>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const result = schema(value, branch, path)\n\n    if (result === true) {\n      return [undefined, value]\n    }\n\n    const failures: Failure[] = []\n\n    if (result === false) {\n      failures.push(Struct.fail({ value, branch, path }))\n    } else if (Array.isArray(result) && result.length > 0) {\n      for (const r of result) {\n        failures.push(Struct.fail({ value, branch, path, ...r }))\n      }\n    } else if (typeof result === 'object') {\n      failures.push(Struct.fail({ value, branch, path, ...result }))\n    } else {\n      invariant(\n        false,\n        `Validator functions must return a boolean, a failure object, or an array of failure objects, but you passed: ${result}`\n      )\n    }\n\n    return [failures]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createInstance = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Instance structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const validator = (value: any) => value instanceof schema\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'instance'\n  Struct.type = `instance<${schema.name}>`\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createInterface = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Interface structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'interface',\n    type: `interface<{${Object.keys(schema).join()}}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (typeof value !== 'object' && typeof value !== 'function') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const failures: Failure[] = []\n\n    for (const k in Props) {\n      const Prop = Props[k]\n      const v = value[k]\n      const [pfs] = Prop.check(v, branch.concat(v), path.concat(k))\n\n      if (pfs) {\n        failures.push(...pfs)\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, value]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createIntersection = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length !== 0,\n    `Intersection structs must be defined as a non-empty array, but you passed: ${schema}`\n  )\n\n  const Structs = schema.map(sch => struct(sch))\n  const type = Structs.map(s => s.type).join(' & ')\n  const Struct = createStruct({\n    kind: 'intersection',\n    type,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    let result: any = value\n\n    for (const struct of Structs) {\n      const [fs, v] = struct.check(value, branch, path)\n\n      if (fs) {\n        return [[Struct.fail({ value, branch, path })]]\n      } else {\n        result = v\n      }\n    }\n\n    return [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Failure, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createLazy = (\n  schema: () => Struct,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'function',\n    `Lazy structs must be defined as a function, but you passed: ${schema}`\n  )\n\n  const Lazy = createStruct({\n    kind: 'lazy',\n    type: `lazy<>`,\n    defaults,\n    struct,\n  })\n\n  Lazy.check = (...args): [Failure[]?, any?] => {\n    Object.assign(Lazy, schema())\n    return Lazy.check(...args)\n  }\n\n  return Lazy\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createSize = (\n  schema: [number, number],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) &&\n      schema.length === 2 &&\n      schema.every(n => typeof n === 'number'),\n    `Size structs must be defined as an array with two number elements, but you passed: ${schema}`\n  )\n\n  const [min, max] = schema\n  const validator = (value: any) =>\n    value != null &&\n    typeof value.length === 'number' &&\n    value.length >= min &&\n    value.length <= max\n\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'size'\n  Struct.type = `size<${min},${max}>`\n  return Struct\n}\n","import { Struct, Superstruct } from '..'\n\nexport const createLiteral = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  const validator = (value: any) => value === schema\n  const Struct = struct(validator, defaults)\n  Struct.kind = 'literal'\n  Struct.type = typeof schema === 'string' ? `\"${schema}\"` : `${schema}`\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createObject = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Object structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'object',\n    type: `{${Object.keys(schema).join()}}`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n    const keys = new Set(Object.keys(Props).concat(Object.keys(value)))\n\n    for (const k of keys) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      if (!(k in Props)) {\n        failures.push(\n          Struct.fail({\n            type: undefined,\n            value: v,\n            path: p,\n            branch: value,\n          })\n        )\n\n        continue\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createPartial = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Partial structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct.union([schema[key], 'undefined'])\n  }\n\n  const Struct = createStruct({\n    kind: 'object',\n    type: `{${Object.keys(schema).join()}}`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (const k of value) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      if (!(k in Props)) {\n        failures.push(\n          Struct.fail({\n            type: undefined,\n            value: v,\n            path: p,\n            branch: value,\n          })\n        )\n\n        continue\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createPick = (\n  schema: {},\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'object',\n    `Pick structs must be defined as an object, but you passed: ${schema}`\n  )\n\n  const Props: Record<string, Struct> = {}\n\n  for (const key in schema) {\n    Props[key] = struct(schema[key])\n  }\n\n  const Struct = createStruct({\n    kind: 'pick',\n    type: `pick<{${Object.keys(schema).join()}}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    const d = Struct.default()\n\n    if (value === undefined) {\n      value = d\n    }\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (const k in Props) {\n      let v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const Prop = Props[k]\n\n      if (v === undefined && d != null && k in d) {\n        v = typeof d[k] === 'function' ? d[k](value, branch, path) : d[k]\n      }\n\n      const [pfs, pr] = Prop.check(v, b, p)\n\n      if (pfs) {\n        failures.push(...pfs)\n      } else if (pr !== undefined && k in Props) {\n        result[k] = pr\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport kindOf from 'kind-of'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createRecord = (\n  schema: [any, any],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length === 2,\n    `Record structs must be defined as an array with two elements, but you passed: ${schema}`\n  )\n\n  const Key = struct(schema[0])\n  const Value = struct(schema[1])\n  const Struct = createStruct({\n    kind: 'record',\n    type: `record<${Key.type},${Value.type}>`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any,\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    // Record structs have a special default handling behavior, where the defaults\n    // are for the entries themselves, not for the entire value. So we can't use\n    // JavaScript's built-in default handling here.\n    const defs = Struct.default()\n    value = defs ? { ...defs, ...value } : value\n\n    if (kindOf(value) !== 'object') {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = {}\n    const failures: Failure[] = []\n\n    for (let k in value) {\n      const v = value[k]\n      const p = path.concat(k)\n      const b = branch.concat(v)\n      const [kfs, kr] = Key.check(k, b, p)\n\n      if (kfs) {\n        failures.push(...kfs)\n      } else {\n        const [vfs, vr] = Value.check(v, b, p)\n\n        if (vfs) {\n          failures.push(...vfs)\n        } else {\n          result[kr] = vr\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { Struct, Superstruct } from '..'\n\nexport const createScalar = (\n  schema: string,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    typeof schema === 'string',\n    `Scalar structs must be defined as a string, but you passed: ${schema}`\n  )\n\n  const { Types } = struct\n\n  invariant(\n    schema in Types,\n    `No struct validator function found for type \"${schema}\".`\n  )\n\n  const Struct = struct(Types[schema], defaults)\n  Struct.kind = 'scalar'\n  Struct.type = schema\n  return Struct\n}\n","import { isStruct, Struct, Superstruct } from '..'\n\nexport const createShorthand = (\n  schema: any,\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  if (isStruct(schema)) {\n    return schema\n  }\n\n  if (Array.isArray(schema)) {\n    if (schema.length === 1) {\n      const [first] = schema\n      return struct.array([first], defaults)\n    } else if (schema.length > 1) {\n      return struct.tuple(schema, defaults)\n    }\n  }\n\n  if (typeof schema === 'function') {\n    return struct.function(schema, defaults)\n  }\n\n  if (typeof schema === 'object') {\n    return struct.object(schema, defaults)\n  }\n\n  if (typeof schema === 'string') {\n    let optional = false\n    let Struct\n\n    if (schema.endsWith('?')) {\n      optional = true\n      schema = schema.slice(0, -1)\n    }\n\n    if (schema.includes('|')) {\n      const scalars = schema.split(/\\s*\\|\\s*/g)\n      Struct = struct.union(scalars, defaults)\n    } else if (schema.includes('&')) {\n      const scalars = schema.split(/\\s*&\\s*/g)\n      Struct = struct.intersection(scalars, defaults)\n    } else {\n      Struct = struct.scalar(schema, defaults)\n    }\n\n    if (optional) {\n      Struct = struct.union([Struct, 'undefined'], undefined)\n    }\n\n    return Struct\n  }\n\n  throw new Error(\n    `A schema definition must be an object, array, string or function, but you passed: ${schema}`\n  )\n}\n","import invariant from 'tiny-invariant'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\nimport { createStruct } from '../struct'\n\nexport const createTuple = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema),\n    `Tuple structs must be defined as an array, but you passed: ${schema}`\n  )\n\n  const Elements = schema.map(s => struct(s))\n  const Struct = createStruct({\n    kind: 'tuple',\n    type: `[${Elements.map(S => S.type).join()}]`,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    if (!Array.isArray(value)) {\n      return [[Struct.fail({ value, branch, path })]]\n    }\n\n    const result = []\n    const failures: Failure[] = []\n    const length = Math.max(value.length, Elements.length)\n\n    for (let i = 0; i < length; i++) {\n      const Element = Elements[i]\n      const v = value[i]\n      const p = path.concat(i)\n      const b = branch.concat(v)\n\n      if (!Element) {\n        failures.push(\n          Struct.fail({ type: undefined, value: v, path: p, branch: b })\n        )\n      } else {\n        const [efs, er] = Element.check(v, b, p)\n\n        if (efs) {\n          failures.push(...efs)\n        } else {\n          result[i] = er\n        }\n      }\n    }\n\n    return failures.length ? [failures] : [undefined, result]\n  }\n\n  return Struct\n}\n","import invariant from 'tiny-invariant'\nimport { createStruct } from '../struct'\nimport { Branch, Failure, Path, Struct, Superstruct } from '..'\n\nexport const createUnion = (\n  schema: any[],\n  defaults: any,\n  struct: Superstruct\n): Struct => {\n  invariant(\n    Array.isArray(schema) && schema.length !== 0,\n    `Union structs must be defined as a non-empty array, but you passed: ${schema}`\n  )\n\n  const Structs = schema.map(sch => struct(sch))\n  const type = Structs.map(s => s.type).join(' | ')\n  const Struct = createStruct({\n    kind: 'union',\n    type,\n    defaults,\n    struct,\n  })\n\n  Struct.check = (\n    value: any = Struct.default(),\n    branch: Branch,\n    path: Path\n  ): [Failure[]?, any?] => {\n    for (const struct of Structs) {\n      const [fs, v] = struct.check(value, branch, path)\n\n      if (!fs) {\n        return [undefined, v]\n      }\n    }\n\n    return [[Struct.fail({ value, branch, path })]]\n  }\n\n  return Struct\n}\n","import { Validator, Types as BuiltinTypes } from './types'\nimport { Branch, Failure, Path, StructError } from './struct-error'\nimport { Struct } from './struct'\nimport {\n  createArray,\n  createDynamic,\n  createEnum,\n  createFunction,\n  createInstance,\n  createInterface,\n  createIntersection,\n  createLazy,\n  createLiteral,\n  createObject,\n  createPartial,\n  createPick,\n  createRecord,\n  createScalar,\n  createShorthand,\n  createSize,\n  createTuple,\n  createUnion,\n} from './structs'\n\n/**\n * `SuperstructSettings` are passed in when creating a `Superstruct` factory.\n */\n\nexport type SuperstructSettings = {\n  types: Record<string, Validator>\n  error: { new (failures: Failure[]): Error }\n}\n\n/**\n * Create a struct singleton with settings that include your own domain-specific\n * data `types`, and an optional custom `Error` class.\n */\n\nexport const superstruct = (\n  settings: Partial<SuperstructSettings> = {}\n): Superstruct => {\n  const struct = (schema: any, defaults?: any): Struct => {\n    return createShorthand(schema, defaults, struct)\n  }\n\n  struct.array = (schema: [any], defaults?: any): Struct => {\n    return createArray(schema, defaults, struct)\n  }\n\n  struct.dynamic = (\n    schema: (value: any, branch: Branch, path: Path) => Struct,\n    defaults?: any\n  ): Struct => {\n    return createDynamic(schema, defaults, struct)\n  }\n\n  struct.enum = (schema: any[], defaults?: any): Struct => {\n    return createEnum(schema, defaults, struct)\n  }\n\n  struct.function = (schema: Validator, defaults?: any): Struct => {\n    return createFunction(schema, defaults, struct)\n  }\n\n  struct.instance = (schema: any, defaults?: any): Struct => {\n    return createInstance(schema, defaults, struct)\n  }\n\n  struct.interface = (schema: any, defaults?: any): Struct => {\n    return createInterface(schema, defaults, struct)\n  }\n\n  struct.intersection = (schema: any[], defaults?: any): Struct => {\n    return createIntersection(schema, defaults, struct)\n  }\n\n  struct.lazy = (schema: () => Struct, defaults?: any): Struct => {\n    return createLazy(schema, defaults, struct)\n  }\n\n  struct.literal = (schema: any, defaults?: any): Struct => {\n    return createLiteral(schema, defaults, struct)\n  }\n\n  struct.object = (schema: {}, defaults?: any): Struct => {\n    return createObject(schema, defaults, struct)\n  }\n\n  struct.optional = (schema: any, defaults?: any): Struct => {\n    return createUnion([schema, 'undefined'], defaults, struct)\n  }\n\n  struct.partial = (schema: {}, defaults?: any): Struct => {\n    return createPartial(schema, defaults, struct)\n  }\n\n  struct.pick = (schema: {}, defaults?: any): Struct => {\n    return createPick(schema, defaults, struct)\n  }\n\n  struct.record = (schema: [any, any], defaults?: any): Struct => {\n    return createRecord(schema, defaults, struct)\n  }\n\n  struct.scalar = (schema: string, defaults?: any): Struct => {\n    return createScalar(schema, defaults, struct)\n  }\n\n  struct.size = (schema: [number, number], defaults?: any): Struct => {\n    return createSize(schema, defaults, struct)\n  }\n\n  struct.tuple = (schema: any[], defaults?: any): Struct => {\n    return createTuple(schema, defaults, struct)\n  }\n\n  struct.union = (schema: any[], defaults?: any): Struct => {\n    return createUnion(schema, defaults, struct)\n  }\n\n  struct.Error = settings.error || StructError\n  struct.Types = { ...BuiltinTypes, ...settings.types }\n  return struct\n}\n\n/**\n * `Superstruct` factories create different kinds of [[Struct]] validators, and\n * encapsulate the user-defined data types.\n *\n * The [[struct]] export is a factory that ships with Superstruct by default,\n * pre-configured with all of the built-in JavaScript data types. It's the\n * easiest way to quickly define structs:\n *\n * ```js\n * import { struct } from 'superstruct'\n *\n * const User = struct({\n *   id: 'number',\n *   name: 'string',\n * })\n * ```\n *\n * If you need to define custom data types, you can define your own by using\n * the [[superstruct]] export:\n *\n * ```js\n * import { superstruct } from 'superstruct'\n * import isEmail from 'is-email'\n * import isUrl from 'is-url'\n *\n * const struct = superstruct({\n *   types: {\n *     email: value => isEmail(value) && value.length < 256,\n *     url: value => isUrl(value) && value.length < 2048,\n *   }\n * })\n *\n * const User = struct({\n *   id: 'number',\n *   name: 'string',\n *   email: 'email',\n *   website: 'url?',\n * })\n * ```\n *\n * This way you can easily define structs that contain types like `'email'`,\n * `'url'`, or whatever else your application may need.\n */\n\nexport interface Superstruct {\n  /**\n   * Structs are defined by passing a schema definition to the struct factory.\n   * The schema definition can be a string, array, object or function. They can\n   * also be composed by nesting structs inside each other.\n   *\n   * The default struct factory allows you to write structs using a shorthand\n   * syntax for the most common casesarrays, objects, scalars, tuples, etc.\n   *\n   * ```js\n   * struct('string') // Scalars\n   * struct(['number']) // Arrays\n   * struct({ name: 'string' }) // Objects\n   * struct(['error', 'string']) // Tuples\n   * struct('number?') // Optional\n   * struct('string & email') // Intersection\n   * struct('number | string') // Union\n   * struct(value => true || false) // Function\n   * struct(Struct) // Pass-through\n   * ```\n   *\n   * Each shorthand is equivalent to a method on the [[Superstruct]] factory:\n   *\n   * ```js\n   * // These are equivalent...\n   * struct(['number'])\n   * struct.array(['number'])\n   *\n   * struct('string & email')\n   * struct.union(['string', 'email'])\n   * ```\n   *\n   * And each one can use your custom types, or even other structs:\n   *\n   * ```js\n   * struct('email')\n   * struct(User)\n   * ```\n   *\n   * The second argument to struct factories is always a `defaults` value. It\n   * can either be the default itself or a function that returns the default.\n   *\n   * ```js\n   * struct('id', uuid.v4)\n   *\n   * struct({\n   *   id: 'number',\n   *   name: 'string',\n   *   is_admin: 'boolean?',\n   * }, {\n   *   is_admin: false,\n   * })\n   * ```\n   */\n\n  (schema: any, defaults?: any): Struct\n\n  /**\n   * Array structs validate that their input is an array with elements that\n   * match a specific struct. You can also pass the `max` or `min` options to\n   * validate the length of the array.\n   *\n   * ```js\n   * const Struct = struct.array(['number'])\n   *\n   * Struct([1, 2, 3])\n   * ```\n   *\n   * They are similar to the `Array` type in TypeScript.\n   */\n\n  array(schema: [any], defaults?: any): Struct\n\n  /**\n   * Dynamic structs are defined by a function that is passed the value being\n   * validated, and they determine which struct to use at runtime.\n   *\n   * ```js\n   * const Struct = struct.dynamic(value => StructA || StructB)\n   * ```\n   *\n   * They are inhernetly less performant that compile-time structs, but they\n   * unlock a set of possibilities that aren't possible at compile time alone.\n   */\n\n  dynamic(\n    schema: (value: any, branch: Branch, path: Path) => Struct,\n    defaults?: any\n  ): Struct\n\n  /**\n   * Enum structs validate that their input is one of a set of values.\n   *\n   * ```js\n   * const Struct = struct.enum(['fruit', 'vegetable', 'meat'])\n   *\n   * Struct('fruit')\n   * ```\n   *\n   * They are similar to the `enum` type in TypeScript.\n   */\n\n  enum(schema: any[], defaults?: any): Struct\n\n  /**\n   * Function structs validate their input against a one-off validator function.\n   *\n   * ```js\n   * const Struct = struct.function(value => typeof value === 'string')\n   *\n   * Struct('a simple string')\n   * ```\n   *\n   * They can't provide as detailed of errors as other struct types, but they do\n   * allow for customization for easy one-off cases.\n   */\n\n  function(schema: Validator, defaults?: any): Struct\n\n  /**\n   * Instance structs validate that their input is an instance of a class.\n   *\n   * ```js\n   * const Struct = struct.instance(MyClass)\n   *\n   * Struct(new MyClass())\n   * ```\n   */\n\n  instance(schema: any, defaults?: any): Struct\n\n  /**\n   * Interface structs validate that their input matches an interface defined as\n   * a set of properties with associated types.\n   *\n   * ```js\n   * const Struct = struct.interface({\n   *   length: 'number',\n   *   indexOf: 'function',\n   * })\n   *\n   * Struct([1, 2, 3])\n   * Struct('abc')\n   * ```\n   *\n   * They are similar to the structural-typing granted by TypeScript.\n   */\n\n  interface(schema: any, defaults?: any): Struct\n\n  /**\n   * Intersection structs validate that their input matches **all** of a set of\n   * different structs.\n   *\n   * ```js\n   * const Struct = struct.intersection('string & email')\n   *\n   * Struct('jane@example.com')\n   * ```\n   *\n   * Note: The structs will be validated in order, so validators on the right\n   * can rely on the validators before them having passed.\n   *\n   * They are similar to the `&` operator in TypeScript.\n   */\n\n  intersection(schema: any[], defaults?: any): Struct\n\n  /**\n   * Lazy structs allow you to initialize a struct lazily, only initializing it\n   * once on the first time it attempts to be validated.\n   *\n   * ```js\n   * const Struct = struct({\n   *   nodes: struct.lazy(() => Struct)\n   * })\n   *\n   * Struct({\n   *   nodes: {\n   *     nodes: { ... }\n   *   }\n   * })\n   * ```\n   *\n   * They are helpful for defining recursive structs.\n   */\n\n  lazy(schema: () => Struct, defaults?: any): Struct\n\n  /**\n   * Literal structs validate their input against a literal value.\n   *\n   * ```js\n   * const Struct = struct.literal(42)\n   *\n   * Struct(42)\n   * ```\n   */\n\n  literal(schema: any, defaults?: any): Struct\n\n  /**\n   * Object structs validate that their input exactly matches an object defined\n   * as a set of properties with associated types.\n   *\n   * ```js\n   * const Struct = struct.object({\n   *   id: 'number',\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   id: 1,\n   *   name: 'Jane Smith',\n   * })\n   * ```\n   *\n   * They are similar to the `?` qualifier in TypeScript.\n   */\n\n  object(schema: {}, defaults?: any): Struct\n\n  /**\n   * Optional structs validate that their input passes a specific struct, or\n   * `undefined`.\n   *\n   * ```js\n   * const Struct = struct.optional('string?')\n   *\n   * Struct('a string of text')\n   * Struct(undefined)\n   * ```\n   *\n   * This is a shorthand for using `struct.union` with `undefined`.\n   */\n\n  optional(schema: any, defaults?: any): Struct\n\n  /**\n   * Partial structs validate that their input partially matches an object\n   * defined as a set of properties with associated types. All of the properties\n   * of the object are optional.\n   *\n   * ```js\n   * const Struct = struct.partial({\n   *   id: 'number'\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   name: 'Jane Smith',\n   * })\n   * ```\n   *\n   * They are similar to the `Partial` utility in TypeScript.\n   */\n\n  partial(schema: {}, defaults?: any): Struct\n\n  /**\n   * Pick structs validate that their input exactly matches a subset of an\n   * object defined as a set of properties with associated types. All of the\n   * properties of its schema are required, but the object can have more that it\n   * does not concern itself with.\n   *\n   * ```js\n   * const Struct = struct.pick({\n   *   id: 'string',\n   *   name: 'string',\n   * })\n   *\n   * Struct({\n   *   id: 1,\n   *   name: 'James Smith',\n   *   email: 'james@example.com',\n   * })\n   * ```\n   *\n   * They are similar to the `Pick` utility in TypeScript.\n   */\n\n  pick(schema: {}, defaults?: any): Struct\n\n  /**\n   * Record structs validate that their input is an object with keys that match\n   * one struct and values that match another. The object can have zero or many\n   * properties set on it.\n   *\n   * ```js\n   * const Struct = struct.record('string', 'number')\n   *\n   * Struct({\n   *   a: 1,\n   *   b: 2,\n   * })\n   * ```\n   *\n   * They are similar to the `Record` utility in TypeScript.\n   */\n\n  record(schema: [any, any], defaults?: any): Struct\n\n  /**\n   * Scalar structs validate that their input passes the `Validator` function\n   * defined for a specific type by name. By default Superstruct ships with a\n   * set of built-in scalars. But you can configure it with custom scalars that\n   * match your domain.\n   *\n   * ```js\n   * const Struct = struct.scalar('string')\n   *\n   * Struct('a string of text')\n   * ```\n   */\n\n  scalar(schema: string, defaults?: any): Struct\n\n  /**\n   * Size structs validate their input has a certain length, by checking its\n   * `length` property. This works strings or arrays.\n   *\n   * ```js\n   * const Struct = struct.size([0, 7])\n   *\n   * Struct([1, 2, 3])\n   * Struct('abcdefg')\n   * ```\n   *\n   * They are helpful for defining unions with array structs.\n   */\n\n  size(schema: [number, number], defaults?: any): Struct\n\n  /**\n   * Tuple structs validate that their input exactly matches a tuple of values,\n   * in length and in type.\n   *\n   * ```js\n   * const Struct = struct.tuple(['string', 'boolean'])\n   *\n   * Struct(['one', true])\n   * ```\n   */\n\n  tuple(schema: any[], defaults?: any): Struct\n\n  /**\n   * Union structs validate that their input matches **at least one** of a set\n   * of different structs.\n   *\n   * ```js\n   * const Struct = struct.union(['string', 'number'])\n   *\n   * Struct('a string')\n   * Struct(42)\n   * ```\n   *\n   * They are similar to the `|` operator in TypeScript.\n   */\n\n  union(schema: any[], defaults?: any): Struct\n\n  /**\n   * The class for errors thrown by `Structs`, defaults to [[StructError]].\n   */\n\n  Error: { new (failures: Failure[]): Error }\n\n  /**\n   * The set of data types that the factory knows.\n   */\n\n  Types: Record<string, Validator>\n}\n","<template>\n  <form\n    ref=\"form\"\n    v-click-outside=\"unTrapFocus\"\n    @submit=\"submitForm\"\n    @click=\"trapFocus\"\n    @focus=\"trapFocus\"\n  >\n    <slot />\n  </form>\n</template>\n\n<script>\nimport serialize from \"form-serialize\";\nimport FocusTrap from \"focus-trap\";\nimport { struct } from \"superstruct\";\nexport default {\n  name: \"FormContainer\",\n  props: {\n    structSchema: {\n      type: Object,\n      required: true\n    }\n  },\n  data() {\n    return {\n      structModel: null,\n      yupSchema: null,\n      trap: \"\",\n      isActive: false,\n      domForm: null\n    };\n  },\n  mounted() {\n    this.domForm = this.$refs.form;\n    this.initStruct();\n    this.initTextAreas();\n    this.initFocusTrap();\n  },\n  methods: {\n    initStruct() {\n      this.structModel = struct(this.structSchema);\n    },\n    initTextAreas() {\n      this.domForm.querySelectorAll(\"[data-autoresize]\").forEach(element => {\n        element.style.boxSizing = \"border-box\";\n        const offset = element.offsetHeight - element.clientHeight;\n        this.domForm.addEventListener(\"input\", event => {\n          event.target.style.height = \"auto\";\n          event.target.style.height = event.target.scrollHeight + offset + \"px\";\n        });\n        element.removeAttribute(\"data-autoresize\");\n      });\n    },\n    initFocusTrap() {\n      this.trap = FocusTrap(this.$refs.form, {\n        clickOutsideDeactivates: true\n      });\n    },\n    trapFocus() {\n      if (!this.isActive) this.trap.activate();\n      this.isActive = true;\n    },\n    unTrapFocus() {\n      if (this.isActive) this.trap.deactivate();\n      this.isActive = false;\n    },\n    validateForm() {\n      return new Promise(resolve => {\n        const formData = serialize(this.$refs.form, { hash: true });\n        const [error, result] = this.structModel.validate(formData);\n        if (error) {\n          const { path, value } = error;\n          // console.log(`Form Container --> Validation error in ${path[0]}: ${value}`)\n          resolve({\n            success: false,\n            data: {\n              path,\n              value,\n              message: `Form Container --> Validation error in ${path[0]}: ${value}`\n            }\n          });\n        }\n        resolve({ success: true, data: result });\n      });\n    },\n    displayValidationErrors(errorsObject, inputOrForm) {\n      // Becareful, errorsObject can come in different structures depending on whether the caller\n      // is an input or the whole form. The if/else check below is to get the correct input name based on that\n      if (inputOrForm === \"input\") {\n        const inputName = errorsObject.path;\n        this.domForm.querySelector(\n          `[data-validation-message=${inputName}]`\n        ).innerHTML = errorsObject.errors[0];\n      } else {\n        errorsObject.errors.forEach((errorMessage, index) => {\n          const inputName = errorsObject.inner[index].path;\n          this.domForm.querySelector(\n            `[data-validation-message=${inputName}]`\n          ).innerHTML = errorMessage;\n        });\n      }\n    },\n    clearValidationErrors(inputName) {\n      this.domForm.querySelector(\n        `[data-validation-message=${inputName}]`\n      ).innerHTML = \"\";\n    },\n    toggleSubmitButton(to) {\n      this.domForm.querySelector(\"button[type=submit]\").disabled = !to;\n    },\n    submitForm(e) {\n      if (e) e.preventDefault();\n      this.validateForm().then(result =>\n        this.$emit(result.success ? \"validated\" : \"errored\", result.data)\n      );\n    }\n  }\n};\n</script>\n","import FormContainer from \"./Form.Container.vue\";\n\nexport default {\n  install(Vue, options) {\n    // Let's register our component globally\n    // https://vuejs.org/v2/guide/components-registration.html\n    Vue.component(\"form-container\", FormContainer);\n  }\n};\n"]}